#
#  We want to input a UML-file (in the USE-tools .soil notation) and generate the corresponding
#  UPPAAL model.
#

import re
from ggggg.fiveg import *


# Loads instance in infile and create sysdict
def LoadSystem(infile, verbose=False):
    # This is used for verbose mode
    def dprint(str):
        if (verbose):
            print(str)

    dprint("Loading file: " + infile)

    # Store all elements as (mostly) python classes
    hosts = []
    vnfs = []
    links = []
    names = []
    routes = []
    slices = []
    routingTables = []
    chains = []
    userEquipments = []
    allocation = {}

    # Contains all assignments gathered from the soil-script
    assignments = {}

    # Contains any errors encountered. If this is empty upon termination, process was ok.
    errors = []

    # Contains all object which were destroyed by the USE-script
    destroyed = []


    # Gets the "python"-id of object [name]
    def id(name):
        return names.index(name)

    # Ensure we only use soil-script files
    assert ".soil" in infile
    f = open(infile, "r")

    def attr(i, attr):
        if attr in assignments[i]:
            return assignments[i][attr]
        else:
            errors.append("Object " + names[i] + " has undefined attribute " + attr)
            return "undef"

    # We have to do some nasty things due to how USE creates soil-scripts
    curpLink = 0
    curvLink = 0

    # Go line by line and update accordingly
    for l in f:
        if "Script generated by USE" in l:
            True
        elif l == "\n":
            True
        elif "!new Host" in l:
            m = re.search('!new Host\(\'(.*)\'\)', l)
            hostName = m.group(1)
            names.append(hostName)
            hosts.append(Host(id(hostName), len(hosts)))
            assignments[id(hostName)] = {}
        elif "!new VNF" in l:
            m = re.search('!new VNF\(\'(.*)\'\)', l)
            vnfName = m.group(1)
            names.append(vnfName)
            vnfs.append(VNF(id(vnfName), len(vnfs)))
            assignments[id(vnfName)] = {}
        elif "!new UserEquipment" in l:
            m = re.search('!new UserEquipment\(\'(.*)\'\)', l)
            ueName = m.group(1)
            names.append(ueName)
            userEquipments.append(UserEquipment(id(ueName), len(userEquipments)))
            assignments[id(ueName)] = {}
        elif "!new Slice" in l:
            m = re.search('!new Slice\(\'(.*)\'\)', l)
            sliceName = m.group(1)
            names.append(sliceName)
            slices.append(Slice(id(sliceName), len(slices)))
            assignments[id(sliceName)] = {}
        # elif "!create Link" in l:
        #     m = re.search('!create (.*): pLink between \\((.*), (.*)\\)', l)
        #     linkName = m.group(1)
        #     names.appe
        #     links.append(Link(id(linkName), len(links), id(m.group(2)), id(m.group(3))))
        #     assignments[id(linkName)] = {}
        elif re.search("!create (.*) vLink between (.*)", l): # vLink = Route
            m = re.search("!create (.*) : vLink between ((.*), (.*))", l)
            vLinkName = m.group(1)
            names.append(vLinkName)
            route = Route(id(vLinkName))
            routes.append(route)
            dprint("Ignoring vLink beginning and end: " + m.group(2) + m.group(3))
            assignments[id(vLinkName)] = {}
        elif "!insert" in l and "into Allocation" in l:
            m = re.search("!insert \\((.*),(.*)\\) into Allocation", l)
            vnfName = m.group(1)
            hostName = m.group(2)
            vnf = next(v for v in vnfs if v.i == id(vnfName))
            host = next(h for h in hosts if h.i == id(hostName))
            allocation[vnf.uid] = host.uid
        elif "!insert" in l and "into Subscription" in l:
            m = re.search("!insert \\((.*),(.*)\\) into Subscription", l)
            # Find UPPAAL id of subscribed slice
            sslice = next(s for s in slices if s.i == id(m.group(2)))
            uppaalid = sslice.uid
            assignments[id(m.group(1))]['subscribedSlice'] = uppaalid
        elif "!insert" in l and "into pLink" in l:
            curpLink += 1
            m = re.search("!insert \\((.*),(.*)\\) into pLink", l)
            linkName = "pLink" + str(curpLink)
            names.append(linkName)
            links.append(Link(id(linkName), len(links), id(m.group(1)), id(m.group(2))))
            assignments[id(linkName)] = {}
        elif "!insert" in l and "into vLink" in l:
            curvLink += 1
            m = re.search("!insert \\((.*),(.*)\\) into vLink", l)
            vLinkName = "vLink" + str(curvLink)
            names.append(vLinkName)
            route = Route(id(vLinkName))
            routes.append(route)
            dprint("Ignoring vLink beginning and end: " + m.group(1) + m.group(2))
            assignments[id(vLinkName)] = {}
        elif " := " in l:
            m = re.search('!(.*)\\.(.*) := (.*)', l)
            name = m.group(1)
            attribute = m.group(2)
            value = m.group(3)
            assignments[id(name)][attribute] = value
        elif re.search("--(.*)", l):
            dprint("Ignoring comment: " + l)
        elif "destroy" in l:
            m = re.search("!destroy (.*)", l)
            did = id(m.group(1))
            destroyed.append(did)
        else:
            print(">>", l)
            ff = open("error.log", "w")
            ff.write(l)
            raise Exception(l)

    routing = routingTables
    alloc = Allocation(allocation)


    def checkDestroyed(el, l):
        for thing in l:
            if thing.i == el:
                l.remove(thing)
                return thing
        return None

    def checkLists(el, lists):
        for l in lists:
            r = checkDestroyed(el, l)
            if (r):
                return r
        return None

    if (destroyed):
        for d in destroyed:
            r = checkLists(d, [hosts, vnfs, slices, userEquipments, links, routes])
            if not r:
                msg = "Did not find destroyed object: " + names[d]
                raise(Exception(msg))
            else:
                print("Destroyed object: " + names[d])


    # Attribute assignments are parsed in a general way and here assigned to correct member
    for h in hosts:
        h.cpu = attr(h.i, 'CPUResources')
        h.stor = attr(h.i, 'StorageResources')
        mecstr = attr(h.i, 'MECHost')
        h.mec = attr(h.i, 'MECHost')

    for v in vnfs:
        v.BCET = attr(v.i, 'BCET')
        v.WCET = attr(v.i, 'WCET')
        v.Prio = attr(v.i, 'Priority')

    for l in links:
        l.bw = assignments[l.i]['Bandwidth']
        l.delay = assignments[l.i]['Delay']

    # Routing requires a bit of translation
    for r in routes:
        print(names[r.i])
        routeString = assignments[r.i]['Links']
        m = re.search("Sequence {(.*)}", routeString).group(1).split(',')
        if m == ['']:
            r.route = []
        else:
            route = []
            for link in m:
                i = id(link.strip())
                l = next(l for l in links if l.i == i)
                route.append(l)
            r.route = route

    # Slices requires a bit more of translation
    for s in slices:
        s.bw = attr(s.i, 'BWRequirement')
        s.lat = attr(s.i, 'LatencyRequirement')

        vnfsString = attr(s.i, 'VNFs')
        m = re.search("Sequence {(.*)}", vnfsString).group(1).split(',')
        vnfSeq = []
        for vnf in m:
            i = id(vnf.strip())
            v = next(v for v in vnfs if v.i == i)
            vnfSeq.append(v)
        chains.append(SliceChain(vnfSeq)) # TODO :Rename this to chains ...

        chainString = attr(s.i, 'Routing')
        m = re.search("Sequence {(.*)}", chainString).group(1).split(',')
        if m == ['']:
            routingTables.append(RoutingTable([]))
        else:
            routingTable = []
            for vlink in m:
                i = id(vlink.strip())
                route = next(r for r in routes if r.i == i)
                routingTable.append(route)

            routingTables.append(RoutingTable(routingTable))
        s.chainLength = len(vnfSeq)

    for ue in userEquipments:
        ue.subscribedSlice = assignments[ue.i]['subscribedSlice']
        ue.maxInst = assignments[ue.i]['MaxInstantiation']
        ue.actTime = assignments[ue.i]['ActivationTime']


    # Put all python classes into a sysdict
    sysdict = {}
    sysdict['Hosts'] = hosts
    sysdict['VNFs'] = vnfs
    sysdict['Links'] = links
    sysdict['Slices'] = slices
    sysdict['UserEquipments'] = userEquipments
    sysdict['Routing'] = routing
    sysdict['Allocation'] = alloc
    sysdict['Chains'] = chains

    return sysdict







# UMLtoUPPAAL
# Takes a [sysdict] and outputs a UPPAAL model to [outfile]. [executorCount] and [queueLength] are used as additional parameters of the translation. If [verbose] lots of extra output is printed to stdout.

def ToUPPAAL(sysdict, outfile, executorCount, queueLength, verbose=False):

    # This is used for verbose mode
    def dprint(str):
        if (verbose):
            print(str)

    # Store all elements as (mostly) python classes
    hosts = sysdict['Hosts']
    vnfs = sysdict['VNFs']
    links = sysdict['Links']
    routing = sysdict['Routing']
    alloc = sysdict['Allocation']
    slices = sysdict['Slices']
    chains = sysdict['Chains']
    userEquipments = sysdict['UserEquipments']

    error = checkSystem(hosts, vnfs, links, slices, chains, alloc, routing, queueLength, executorCount)

    if not (error == ""):
        print("ERRORS")
        return (error, None)
    else:
        outstring = generateSystem(hosts, vnfs, links, slices, chains, alloc, routing, userEquipments, queueLength, executorCount)

        assert ".xml" in outfile
        f = open(outfile, "w")
        f.write(outstring)

        return (error, sysdict)
