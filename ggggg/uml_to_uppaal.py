#  We want to input a UML-file (in the USE-tools .soil notation) and generate the corresponding
#  UPPAAL model.
#

import re
from ggggg.fiveg import *

### uid = uppaal_id and has to be from 0 to |hosts|-1, etc.
### should be updated before model is generated

# Loads instance in infile and create sysdict
def LoadSystem(infile, verbose=False):
    # This is used for verbose mode
    def dprint(str):
        if (verbose):
            print(str)

    dprint("Loading file: " + infile)

    # Store all elements as (mostly) python classes
    hosts = []
    vnfs = []
    links = []
    paths = []
    slices = []
    routingTables = []
    chains = []
    userEquipments = []
    allocation = {}

    # Storing id and reference for all objects for access
    names = []
    objects = []

    # Contains all assignments gathered from the soil-script
    assignments = {}

    # Contains any errors encountered. If this is empty upon termination, process was ok.
    errors = []

    # Contains all object which were destroyed by the USE-script
    destroyed = []


    # Gets the "python"-id of object [name]
    def myid(name):
        return names.index(name)

    # Ensure we only use soil-script files
    assert ".soil" in infile
    f = open(infile, "r")

    def attr(i, attr):
        if attr in assignments[i]:
            return assignments[i][attr]
        else:
            # errors.append("Object " + names[i] + " has undefined attribute " + attr)
            return None

    # We have to do some nasty things due to how USE creates soil-scripts
    curLink = 0
    curvLink = 0

    # Go line by line and update accordingly
    for l in f:
        if "Script generated by USE" in l:
            True
        elif l == "\n":
            True
        elif "!new Host" in l:
            m = re.search('!new Host\(\'(.*)\'\)', l)
            hostName = m.group(1)
            names.append(hostName)
            newHost = Host(myid(hostName), hostName, len(hosts))
            hosts.append(newHost)
            objects.append(newHost)
            assignments[myid(hostName)] = {}
        elif "!new VNF" in l:
            m = re.search('!new VNF\(\'(.*)\'\)', l)
            vnfName = m.group(1)
            names.append(vnfName)
            newVNF = VNF(myid(vnfName), vnfName, len(vnfs))
            vnfs.append(newVNF)
            objects.append(newVNF)
            assignments[myid(vnfName)] = {}
        elif "!new UserEquipment" in l:
            m = re.search('!new UserEquipment\(\'(.*)\'\)', l)
            ueName = m.group(1)
            names.append(ueName)
            newUE = UserEquipment(myid(ueName), len(userEquipments))
            userEquipments.append(newUE)
            objects.append(newUE)
            assignments[myid(ueName)] = {}
        elif "!new Slice" in l:
            m = re.search('!new Slice\(\'(.*)\'\)', l)
            sliceName = m.group(1)
            names.append(sliceName)
            newSlice = Slice(myid(sliceName), sliceName, len(slices))
            slices.append(newSlice)
            objects.append(newSlice)
            assignments[myid(sliceName)] = {}
        elif re.search("!create (.*) Path between (.*)", l): # vLink = Path
            m = re.search("!create (.*) : Path between ((.*), (.*))", l)
            PathName = m.group(1)
            names.append(PathName)
            path = Path(myid(PathName))
            paths.append(path)
            objects.append(path)
            dprint("Ignoring Path beginning and end: " + m.group(2) + m.group(3))
            assignments[myid(PathName)] = {}
        elif "!insert" in l and "into Allocation" in l:
            m = re.search("!insert \\((.*),(.*)\\) into Allocation", l)
            vnfName = m.group(1)
            hostName = m.group(2)
            vnf = next(v for v in vnfs if v.i == myid(vnfName))
            host = next(h for h in hosts if h.i == myid(hostName))
            allocation[vnf] = host
        elif "!insert" in l and "into Subscription" in l:
            m = re.search("!insert \\((.*),(.*)\\) into Subscription", l)
            # Find UPPAAL id of subscribed slice
            sslice = next(s for s in slices if s.i == myid(m.group(2)))
            uppaalid = sslice.uid
            assignments[myid(m.group(1))]['subscribedSlice'] = uppaalid
        elif "!insert" in l and "into Link" in l:
            curLink += 1
            m = re.search("!insert \\((.*),(.*)\\) into Link", l)
            linkName = "Link" + str(curLink)
            names.append(linkName)
            newLink = Link(myid(linkName), len(links), objects[myid(m.group(1))], objects[myid(m.group(2))])
            links.append(newLink)
            objects.append(newLink)
            assignments[myid(linkName)] = {}
        elif "!insert" in l and "into Path" in l:
            curPath += 1
            m = re.search("!insert \\((.*),(.*)\\) into Path", l)
            PathName = "Path" + str(curPath)
            names.append(PathName)
            path = Path(myid(PathName))
            paths.append(path)
            objects.append(path)
            dprint("Ignoring Path beginning and end: " + m.group(1) + m.group(2))
            assignments[myid(PathName)] = {}
        elif " := " in l:
            m = re.search('!(.*)\\.(.*) := (.*)', l)
            name = m.group(1)
            attribute = m.group(2)
            value = m.group(3)
            assignments[myid(name)][attribute] = value
        elif re.search("--(.*)", l):
            dprint("Ignoring comment: " + l)
        elif "destroy" in l:
            m = re.search("!destroy (.*)", l)
            did = myid(m.group(1))
            destroyed.append(did)
        else:
            print(">>", l)
            ff = open("error.log", "w")
            ff.write(l)
            raise Exception(l)

    routing = routingTables
    alloc = Allocation(allocation)

    def checkDestroyed(el, l):
        for thing in l:
            if thing.i == el:
                l.remove(thing)
                return thing
        return None

    def checkLists(el, lists):
        for l in lists:
            r = checkDestroyed(el, l)
            if (r):
                return r
        return None

    if (destroyed):
        for d in destroyed:
            r = checkLists(d, [hosts, vnfs, slices, userEquipments, links, paths])
            if not r:
                msg = "Did not find destroyed object: " + names[d]
                raise(Exception(msg))
            else:
                print("Destroyed object: " + names[d])


    # Attribute assignments are parsed in a general way and here assigned to correct member
    for h in hosts:
        h.cpu = attr(h.i, 'CPUResources')
        h.mem = attr(h.i, 'MemoryResources')
        h.mec = attr(h.i, 'MECHost')
        capString = attr(h.i, 'Capabilities')
        m = re.search("Set {(.*)}", capString).group(1).split(',')
        tmp = []
        if not m == ['']:
            for vnfType in m:
                tmp.append(vnfType.strip())
        h.capabilities = tmp

    for v in vnfs:
        v.BCET = attr(v.i, 'BCET')
        v.WCET = attr(v.i, 'WCET')
        v.Type = attr(v.i, 'Type')

    for l in links:
        l.bw = assignments[l.i]['Bandwidth']
        l.delay = assignments[l.i]['Delay']

    # Routing requires a bit of translation
    for r in paths:
        pathString = assignments[r.i]['Links']
        m = re.search("Sequence {(.*)}", pathString).group(1).split(',')
        if m == ['']:
            r.path = []
        else:
            path = []
            for link in m:
                i = myid(link.strip())
                l = next(l for l in links if l.i == i)
                path.append(l)
            r.path = path

    # Slices requires a bit more of translation
    for s in slices:
        s.bw = attr(s.i, 'BWRequirement')
        s.lat = attr(s.i, 'LatencyRequirement')
        s.prio = attr(s.i, 'Priority')

        vnfsString = attr(s.i, 'VNFs')
        m = re.search("Sequence {(.*)}", vnfsString).group(1).split(',')
        typeSeq = []
        for t in m:
            typeSeq.append(t.strip())
        chains.append(Chain(typeSeq)) 
        s.chainLength = len(typeSeq)

        ## Routing might not be described
        chainString = attr(s.i, 'Routing')
        if not not chainString:
            m = re.search("Sequence {(.*)}", chainString).group(1).split(',')
            if m == ['']:
                routingTables.append(RoutingTable([]))
            else:
                routingTable = []
                for vlink in m:
                    i = myid(vlink.strip())
                    path = next(r for r in paths if r.i == i)
                    routingTable.append(path)

                routingTables.append(RoutingTable(routingTable))

    for ue in userEquipments:
        ue.subscribedSlice = assignments[ue.i]['subscribedSlice']
        ue.maxInst = assignments[ue.i]['MaxInstantiation']
        ue.actTime = assignments[ue.i]['ActivationTime']

    if (errors):
        for e in errors:
            print(e)

    def updateUID(ls):
        for i, e in enumerate(ls):
            e.uid = i

    ### UPDATE uis
    for ll in [hosts, vnfs, links, slices]:
        updateUID(ll)

    # Put all python classes into a sysdict
    sysdict = {}
    sysdict['Hosts'] = hosts
    sysdict['VNFs'] = vnfs
    sysdict['Links'] = links
    sysdict['Slices'] = slices
    sysdict['UserEquipments'] = userEquipments
    sysdict['Routing'] = routing
    sysdict['Allocation'] = alloc
    sysdict['Chains'] = chains

    return sysdict


# UMLtoUPPAAL
# Takes a [sysdict] and outputs a UPPAAL model to [outfile]. [executorCount] and [queueLength] are used as additional parameters of the translation. If [verbose] lots of extra output is printed to stdout.

def ToUPPAAL(sysdict, outfile, executorCount, queueLength, verbose=False):
    sysdict['Executors'] = executorCount
    sysdict['QueueLength'] = queueLength

    outstring = generateSystem(sysdict)
    
    assert ".xml" in outfile
    f = open(outfile, "w")
    f.write(outstring)

    return None

